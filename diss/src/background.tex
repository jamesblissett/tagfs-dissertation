\chapter{Background}
\vspace{1cm}

Background blah.

\section{File Systems}

The file system is a fundamental abstraction for almost all modern operating
systems. The abstraction allows the operating system and user programs to
interact with a variety of devices and services through a single unified
interface.
The purpose of a specific file system is to implement this common interface for
a particular underlying data store. The exact nature of the data store is not
important to the consumer of the file system's interface. The underlying data
store is commonly a physical storage device such as a hard disk drive (HDD).
However, it is important to note that this is not always the case and there is
no requirement for a file system to manage a physical storage device. File
systems that depend on another file system as their underlying data store are
known as a VFS (virtual file system).

The high level filing cabinet metaphor that is built on the low level interface
provided by a particular file system implementation will be familiar to most
computer users. The metaphor consists of a filing cabinet containing many named
files. These files can contain arbitrary data. However, some of these files may
not contain data themselves but rather other files, and in this case they are
called directories (or folders in some versions of the metaphor). This nesting
of files within directories creates a hierarchical structure where a single
root directory (analogous to the filing cabinet) contains an arbitrarily
deeply nested series of files and directories. The hierarchy of files within
directories can conceptually be arbitrarily deep, but most particular
implementations enforce a limit for simplicity. The filing cabinet metaphor is
also useful in demonstrating that a file or directory can only be contained
within one other directory. Each file or directory (excluding the root
directory) must have one and only one parent in the hierarchy.

In Figure \ref{fig:sample file hierarchy} there are two distinct files named
\texttt{timeline.txt}. It becomes ambiguous to refer to a file only by its name
when this is the case. It is useful to use the steps taken to arrive at a file
or directory to identify it within the file hierarchy. For example, the steps
taken to arrive at \texttt{timeline.txt} would be \texttt{/} then
\texttt{documents} then \texttt{project1} then \texttt{timeline.txt}. This list
of steps is known as a path and can be written as a \texttt{/} delimited list
of the steps taken to reach a file or directory. Using the previous example the
path would be \texttt{/documents/project1/timeline.txt}. As a result of the
single parent rule, each file or directory has a single path that uniquely
identifies it amongst all other files and directories in the hierarchy.
\todo{This is not true when you add links into the equation.} \todo{Explain the
difference between absolute and relative paths.}

% Sample file hierarchy figure {{{
\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance=0.5cm]
    \tikzset{file/.style={rectangle, rounded corners, text=olive, text
        width=1cm, font=\ttfamily}}
    \tikzset{directory/.style={rectangle, rounded corners, text=teal, text
        width=1cm, font=\ttfamily}}
    \tikzset{root directory/.style={rectangle, rounded corners, text=teal,
        font=\ttfamily}}
    \tikzset{arrow/.style=thick}

    \node (root) [root directory] {/};
    \node (code) [directory, below of=root, xshift=1cm] {code};
    \node (mainc) [file, below of=code, xshift=1cm] {main.c};
    \node (makefile) [file, below of=mainc] {Makefile};
    \node (documents) [directory, below of=makefile, xshift=-1cm] {documents};
    \node (project1) [directory, below of=documents, xshift=1cm] {project1};
    \node (timeline1) [file, below of=project1, xshift=1cm] {timeline.txt};
    \node (project2) [directory, below of=timeline1, xshift=-1cm] {project2};
    \node (timeline2) [file, below of=project2, xshift=1cm] {timeline.txt};
    \node (projectstxt) [file, below of=timeline2, xshift=-1cm] {projects.txt};
    \node (images) [directory, below of=projectstxt, xshift=-1cm] {images};
    \node (scanjpg) [file, below of=images, xshift=1cm] {scan.jpg};

    \draw [arrow] (root) |- (code);
    \draw [arrow] (code) |- (mainc);
    \draw [arrow] (code) |- (makefile);
    \draw [arrow] (root) |- (documents);
    \draw [arrow] (documents) |- (project1);
    \draw [arrow] (project1) |- (timeline1);
    \draw [arrow] (documents) |- (project2);
    \draw [arrow] (project2) |- (timeline2);
    \draw [arrow] (documents) |- (projectstxt);
    \draw [arrow] (root) |- (images);
    \draw [arrow] (images) |- (scanjpg);
\end{tikzpicture}
\caption[Sample file hierarchy]{Sample file hierarchy with directories in blue
    and files in green.}
\label{fig:sample file hierarchy}
\end{figure}
% }}}

\subsection{Operating Systems and the File System}

\todo{
    Talk about how ls makes a system call and the kernel receives it and then
    calls the fuse kernel module who then writes to unix socket which fuser
    (Rust) reads who then calls me. In the general case libFUSE would call the
    libc function mount with fs type 'fuse'. In my case fuser calls fusermount3
    and listens to the returned unix socket for messages from the kernel.
}

The primary way most users interact with file systems is through a GUI
(graphical user interface) file manager such as \texttt{thunar} or
\texttt{nautilus}. \todo{Maybe screenshot of file manager with tree view?}
However, it is also possible to manage a file system without a GUI and use CLI
(command line interface) tools such as \texttt{ls} or \texttt{mv}. Both GUI
file managers and CLI tools utilise the low level interface exposed by the
operating system and implemented by a particular file system. The traditional
way to use this interface is via a library exposed by the operating
system\footnote{\todo{Something about how libc is required on Windows because
it does not have a stable syscall interface.}}. \todo{Not sure if I should stay
abstract about a particular operating system or be specifically about
UNIX-likes here.} On UNIX-like operating systems this library is \texttt{libc}.
\todo{Do I need to talk about the difference between an abstract libc and
concrete like glibc or musl?} The overwhelming majority of programs that run on
UNIX-like operating systems use \texttt{libc} to help them interact with the
platform. The operating systems' \texttt{libc} contains functions that require
access to the file system (such as \texttt{stat}). To get access to the file
system the \texttt{libc} function will execute a system call (often called a
syscall). A system call is a way for an unprivileged user program to ask the
operating system to perform an action on its behalf. When executed, a system
call performs a context switch and jumps into kernel code\footnote{\todo{Not
necessarily! See virtual syscalls and vdso on linux.}}. The kernel is the part
of the operating system that, amongst many other functions, responds to system
calls. When the kernel responds to a system call that requires accessing the
file system, it must first ascertain which file system implementation to call.
\todo{On Linux this is the VFS layer in the kernel.} Once this is determined
the kernel asks the file system implementation to perform the action specified
by the system call. It also may return some data to the calling user program
via a buffer or a return value.
