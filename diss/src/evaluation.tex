\chapter{Evaluation}
\vspace{1cm}

\todo{Probably this is better in another section I think? Talk about who the
users are and why it is appropriate for them here?}

\todo{Talk about potential future improvements and why they would be
improvements for the intended userbase}

\todo{Does the software do what it is supposed to do?}

I believe that the \texttt{tagfs} software is useful and achieves its goals of
implementing a method of tag based file management via a virtual file system.
This is realised by the file system component of \texttt{tagfs} that allows the
user to browse and query their files in a more abstract way by using tags
instead of file system paths. The additional task of tag management takes place
using the command line tool. Together these allow a user to have a reasonably
complete tag-based file management experience. The implementation of the
virtual file system of \texttt{tagfs} is robust and handles edge cases
gracefully without unintended crashes. This is achieved through extensive use
of Rust's ``Result'' type to easily propagate errors higher up the call stack
to where they are more relevant, and via attaching context messages to lower
level error messages to make them more user friendly for both the programmer
and the user. Using the Rust ``Result'' type also makes thinking about error
handling mandatory, because to access a value wrapped in a result type you must
handle the error or explicitly ignore the error. With the use of this pattern,
it is impossible to forget to handle an error as all error handling is
explicit. This is in contrast to languages such as C where error handling is
often handled through negative return values (this is the case with the fork()
libc function) this makes it very easy to forget to handle error cases and as a
result can reduce the robustness of the software.

The design of the system is flexible and does not restrict the user or funnel
them towards any particular tagging methodology. This allows the user to create
their own tagging system backed by \texttt{tagfs} rather than forcing a
structure onto them. This flexibility is especially appreciated by the target
user base, because (as power users) they do not want to be artificially
constrained within a system that limits them to only the ideas that the
developer originally thought of. The idea of flexibility is also extended to
the command line component of \texttt{tagfs}, which is specifically designed to
allow extensibility via the traditional UNIX method of pipes and shell scripts.
This again allows the user to mould the system to their preference rather than
relying on the developer to have conceived of every use case beforehand.
Sticking to established platform conventions for the CLI, allows the user to
easy integrate \texttt{tagfs} into their existing command line based workflow,
and allows the software to feel more natural to existing technical users.

\section{Potential Future Work}

\todo{Tag dependency or grouping - eg a 'film' tag implies that you must have
an 'imdb' tag also.}

Due to the modular design and iterative development style used to develop the
\texttt{tagfs} project, it would be easy to extend the project with new
features and even entirely new interfaces. For example, it could be interesting
to create a GUI for \texttt{tagfs}. This would allow users to browse and edit
the tag database in a more visual way. A more visual style of tag manipulation
could broaden the intended user base considerably. This is because allowing the
users to modify the tag database through a GUI would remove the requirement for
a user to have experience with the command line, and since almost all
non-technical users are inexperienced with the command line this could
potentially create a more feasible route to them using \texttt{tagfs}. For
technical users however, I do not think a GUI would bring a great deal of
value. This is because I think that most technical users would want to automate
their interactions with \texttt{tagfs} via scripting, and only rarely would
they need to manually interact with the program. In this case of rare manual
interaction, it would not make sense to open a dedicated GUI and attempt to
remember its idiosyncrasies. I also believe technical users would prefer to
interact via the CLI because it would be more familiar to them after having
development scripts around it.

Another potential avenue that the project's development could be taken down is
allowing the user to modify the tag database from the file system. This would
make using the CLI tool less necessary, and make editing the tag database more
intuitive and natural. There are lots of ways a feature like this could work.
One way would be to allow the user to remove a tag directory within the virtual
file system, the file system would then intercept the request and as a
consequence remove the tag represented by the deleted directory from all file
paths that it is currently tagged on. Another way could be to allow the editing
of a file's tags by editing the ``.tags'' file that is automatically generated
by the file system. This could work similarly to the edit subcommand from the
CLI. Even deleting a ``.tags'' file could be implemented to remove all traces
of that file path from the tag database.

One feature that could be useful for users would be the ability to customise
the autotagging process. This could be done with custom user created rules that
use regular expressions to match path components or specific file metadata.
After a rule has been matched, an action can take place to generate tags for
the matched file. This could be as simple as assigning a static string to a
given rule or as complex as allowing an external script to be used to generate
a set of tags. This would allow the user to be more confident in using the
autotagging feature as they would be sure it would tag files exactly to their
specifications, and an increase in the usage of autotagging means there is less
friction in adding new files to the system.
