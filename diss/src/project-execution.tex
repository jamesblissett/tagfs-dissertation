\chapter{Project Execution}
\vspace{1cm}

\todo{Say what my project actually is.}
My project is a tag-based FUSE file system (from now on creatively referred to
as `tagfs'). Tagfs is written in the Rust programming language and relies on
the `fuser' library to communicate with and decode messages from the FUSE
kernel module. Tagfs also makes use of the SQLite database library through the
Rust wrapper interface provided by `rusqlite'. Specific features of tagfs are
discussed in more detail in Section \ref{section:features}. \todo{This feels
like maybe it should be part of the introduction?}
\todo{Talk about what exactly a tag is?}

\section{Design}

\subsection{Technology Choices}

Choosing suitable technology is a vital component of a successful software
project. Unsuitable technology can result in a project being much more complex,
brittle, and unmaintainable than it otherwise could have been. \todo{source?
(dude just trust me)}

I chose Rust as the implementation language for my project. One of the factors
that pushed me towards Rust was my prior experience creating small hobby
projects using the language. In these smaller past projects I had found the
features of Rust, such as its strong static type system and focus on
correctness, to lend themselves to producing robust and maintainable systems.
Additionally, the potential performance of a Rust solution (due to Rust's lack
of a runtime garbage collector) attracted me, because file system code requires
good performance to avoid frustrating the user or slowing down other programs
that depend on it. However, I did have some concerns about the choice of Rust.
My main concern was, due to the fact that Rust is a relatively young
programming language\footnote{Rust 1.0 was released in 2015
(\url{https://blog.rust-lang.org/2015/05/15/Rust-1.0.html}) most other widely
used programming languages were first released at least 20 years earlier.},
there would not be many high quality libraries available. It was a pleasant
surprise then that when browsing the Rust community repository
crates.io\footnote{\url{https://crates.io/}}, I found many projects with active
communities that appeared to be reasonably mature and usable. My heuristic for
identifying these libraries is based on the number of downloads on crates.io
and the last commit date on GitHub. I found that libraries with a high number
of downloads tended to represent the best the community had to offer in that
particular category. Libraries with lots of recent commits tend to have more
active communities and that often means that there are people asking questions
and receiving answers which is useful to fill in any gaps in the documentation.

\todo{Why is Rust a suitable programming language for my project?
Alternatives? Why Rust not C?}

\subsubsection{Data Storage Back-end}

Early on in the planning phase of my project I knew I was going to need some
mechanism to persist data to the file system between mounts of the file system.
I knew my data would be at least vaguely relational, because I knew that I
needed to model the relationship between a file system path and the tags
associated with it. This is what initially drew me to a database solution
rather than a simpler flat text file. However, the main reason I chose to use
an SQL database was the ability to constrain my data and enforce invariants at
the database level. While it is possible to do this with a flat file approach,
I believed that this would be difficult to implement and less performant than
using a database.

Once I had decided that I was going to use a database, my choice of which
database implementation to use was very easy. SQLite is the most deployed
database software on the planet \cite{sqlite-most-used}, and it is perfect for
my use case of a local data store. It is fast, battle-tested, and well
documented. Unsurprisingly, there is a Rust wrapper library for
SQLite\footnote{This highlights another important Rust feature: its foreign
function interface (FFI)}. Rusqlite packages up SQLite into a more Rust-like
interface suitable for use from entirely safe code. \todo{Make sure I have
talked about the distinction between safe and unsafe Rust code somewhere.}

\todo{Why did I choose SQLite? Alternatives? Flat File? Own Format? NoSQL? ORM?}

\subsection{Database Schema Design}
\todo{Not sure how much I can squeeze out of this tbh.}

\section{Features}
\label{section:features}

Tagfs exposes two different interfaces for the user to interact with: a CLI and
a file system interface. The CLI uses both the classic UNIX style options
(\texttt{--help} or \texttt{--database}) and a more modern (at least as far as
CLIs go) subcommand style interface similar to the \texttt{git} CLI.

% tagfs CLI {{{
\begin{figure}[h]
    \centering
    \begin{boxedverbatim}
$ tagfs help
Tag-based virtual file system backed by SQLite.

Usage: tagfs [OPTIONS] <COMMAND>

Commands:
tag             Apply a tag to a path
untag           Remove a tag from a path
mount           Mount the filesystem [aliases: mnt, m]
tags            Display tags associated with a path
query           Query the database [aliases: q, search]
autotag         Autotag a directory tree or file
prefix          Modify the prefix of paths in the database
edit            Edit the tags database using a text editor
stored-queries  List, create and delete stored queries in the database
help            Print this message or the help of the given subcommand(s)

Options:
    --database <database>  Path to database to use or create
-h, --help                 Print help
-V, --version              Print version
    \end{boxedverbatim}
    \caption[Help for \texttt{tagfs} CLI]{Help for tagfs. Shown when the
        \texttt{tagfs} or \texttt{tagfs help} command is run. \todo{MAKE SURE
        TO KEEP THIS UPDATED.}}
    \label{fig:root-cli}
\end{figure}
%stopzone stops vim syntax highlighting running over.
% }}}

Each subcommand acts as if it is its own self contained program with its own
options and arguments. However, there are some options that all of the
subcommands share, these can been seen at the bottom of
Figure~\ref{fig:root-cli}. The \texttt{--database} option specifies the SQLite
database to use for a specific subcommand. If this option is given, but the
database does not exist at the given location then a new database is created at
the specified location. If this option is not given at all then, following the
XDG base directory specification \cite{xdg-base-dir-spec}, a sensible default
location is found. If a database is found at this location then it is used, but
if there is no database then an empty one is created.

The \texttt{tag} and \texttt{untag} subcommands are both straightforward CRUD
actions in the database, create and delete respectively. Both subcommands take
a path and a list of tags. The \texttt{tag} subcommand tags the given path with
each tag in turn. The \texttt{untag} subcommand removes each given tag from the
given path. If the list of tags given is empty then \texttt{untag} removes all
tags from the given path.

The \texttt{mount} subcommand mounts the FUSE file system at the given mount
point. The FUSE file system is discussed in more detail in
Section~\ref{sec:fs-features}.

The \texttt{tags} subcommand lists all of the tags stored on a given path. The
information provided by this command is also exposed through the FUSE file
system. The situation is similar for the \texttt{query} subcommand. The
subcommand takes a query and lists all of the paths that match. Queries are
discussed in more detail in Section~\ref{sec:queries}.

The \texttt{autotag} subcommand takes a path. If the path is a directory then
the subcommand will recursively search the directory for all its descendants
that are files. Each of these files is checked to see if they are of a type
that the \texttt{autotag} subcommand recognises. If \texttt{autotag} recognises
a file's type then it will attempt to extract or generate tags based on the
file's content. For example, if \texttt{autotag} comes across an MP3 file it
will try and extract the file's metadata tags and build tags based on them.
\todo{Show example.} The software also recognises image files and can extract
metadata from these also. \todo{Talk about recognising film files.}

The \texttt{prefix} subcommand is used for searching and replacing components
of the paths stored in the database. It takes two strings as arguments: the
term to search for and the term to replace it with. It then scans the database
for any paths matching the search term and replaces the match with the given
replacement text. This subcommand is designed to reduce the burden of updating
the database after you have moved some files. For example, you might have moved
your music directory to another location on your system, and using the prefix
command you can update all of the paths for your music files to use the new
location in one go.

The \texttt{edit} subcommand is used to make fine-grained edits to the database
with the comfort of a familiar interface. This subcommand dumps the contents of
the database to a temporary file in a human-readable format. Then the
subcommand invokes the user's preferred editor\footnote{It finds the user's
preferred editor by first reading the \texttt{\$VISUAL} environment variable and
failing that it tries the \texttt{\$EDITOR} environment variable before falling
back to a default value.} on the temporary file and waits for the editor
process to terminate. Once the editing session is complete, the \texttt{edit}
subcommand checks to see if the user has made any changes to the temporary
file and, if they have, commits them to the database.

% edit subcommand format figure {{{
\begin{figure}[h]
    \centering
    \begin{boxedverbatim}


--------
/path/to/tagged/file
tag1=value
tag2
tag3=long\ value
--AUTO--
autotag=autovalue
--------

--------
/path/to/another/tagged/file
tag1=other-value
tag2
--AUTO--
another-autotag=autovalue
--------
    \end{boxedverbatim}
    \label{fig:edit-subcommand-format}
    \caption{Example of the \texttt{edit} subcommand editing session.}
\end{figure}
% }}}

Figure~\ref{fig:edit-subcommand-format} shows a potential editing session. The
file is split into blocks delimited by eight dashes. Each block represents one
path in the database. The path is specified as the first non-empty line inside
the block. Each non-empty line after that specifies a single tag to be applied
to the path given at the start of the block. The tags are read in the exact
same way as a query (more detail about query syntax in
Section~\ref{sec:queries}) with the additional constraint of only being
allowed to contain one tag and an optional value. There is also the possibility
of an `\texttt{--AUTO--}' heading somewhere in the block. Any tags read after
this special heading, are marked as being generated by the \texttt{autotag}
subcommand. This is useful to separate user defined tags from automatically
generated ones. This separation is important so that the \texttt{autotag}
subcommand knows which tags are safe to overwrite. \todo{Make this actually
exist in the code.}

The user may make changes to any part of the temporary file, including removing
entire blocks, removing the `\texttt{--AUTO--}' special heading, and changing
the path entirely.

\todo{Finish talking about the rest of the subcommands.}

\subsection{Queries}
\label{sec:queries}

Whilst using tagfs there are multiple contexts in which the user may be asked
for a query. These are when using the FUSE file system and when using the
\texttt{query} subcommand. A query is an expression which any particular path
in the database either satisfies or does not satisfy.

At the most basic level, a query can contain a single tag, for example
\texttt{favourite}. This query matches all the paths in the database that have
been tagged with the tag ``favourite''. This is useful on its own, but not very
powerful. However, it is possible to combine multiple tags into a single query
with boolean operators. One such operator is the \texttt{and} operator. It
matches a path if both its operands match. For example, the query
\texttt{favourite and watched} matches all the paths tagged with both
``favourite'' and ``watched''. Additionally, there is a union operator
\texttt{or} that matches a path if either or both of its operands match. A
query can also be inverted by using the \texttt{not} operator. For example, the
query \texttt{not favourite} matches all paths in the database that are not
tagged with ``favourite''. These operators can be combined in many ways to
produce arbitrary expressions. For example, the query \texttt{not favourite and
(not watched or recent)} matches any paths that do not have the ``favourite''
tag and have the ``recent'' tag or don't have the ``watched'' tag. In the
previous query parentheses are used to group parts of the expression
differently than without. Query expressions follow the conventional precedence
rules that specify that parentheses have the highest precedence, followed by
\texttt{not}, followed by \texttt{and}, followed by \texttt{or}.

In the database it is possible for tags to be associated with values, so the
query language supports matching on a tag's value as well as just the tag's
presence. Query expressions can be formed by using a comparison operator along
with a tag and a value. The most common comparison operator is \texttt{=} it is
used to test whether a tag's value contains a particular substring\footnote{By
default the \texttt{=} operator is not case sensitive. This can be adjusted via
a flag on the \texttt{query} subcommand.}. For example, the query
\texttt{title=before} matches any paths that have a tag called ``title'' with a
value containing the string ``before''. Another comparison operator is
\texttt{==} (strict or exact equals) this is similar to the standard \texttt{=}
operator except the given value must be exactly the same as the value attached
to the tag in the database for it to match. The final two comparison operators
are the less than \texttt{<} and greater than \texttt{>} operators. These match
a path if the path has the given tag and the tag's value is less than or
greater than (depending on the operator used) the value given in the query. The
ordering used to determine whether a value is less than or greater than another
is lexicographical. This can produce behaviour that may be surprising such as
the fact that `$2$'~$>$~`$10$'. These comparison operators can of course be
combined with the earlier described boolean operators to create more complex
query expressions. The values used with the comparison operators must be
escaped properly to ensure the query's semantics. For example, the query
\texttt{genre=science fiction} is invalid because values are terminated by a
space character, so this is parsed as two separate tags ``genre'' and
``fiction''. Since there is no comparison operator between them, the query is
invalid and is therefore rejected. To achieve the desired meaning the value
associated with a tag can be escaped or quoted. For example, to query for a
path with the tag ``genre'' and value ``science fiction'' the two forms
\verb_genre=science\ fiction_ and \texttt{genre="science fiction"} can be used
and both have the same meaning.

The query syntax is specified more precisely in Figure~\ref{fig:query-bnf}
using BNF notation.

% query grammar {{{
\begin{figure}[h]
\begin{grammar}
<query> ::= <term> <whitespace> <binary-bool-op> <whitespace> <query>
    \alt <unary-bool-op> <whitespace> <query>
    \alt `(' <maybe-whitespace> <query> <maybe-whitespace> `)'
    \alt <term>

<term> ::= <tag> <maybe-whitespace> <comp-op> <maybe-whitespace> <value>
    \alt <tag>

<tag> ::= <tag-char> <tag> | <tag-char>

<tag-char> ::= \{Set of non-whitespace, non-control Unicode characters\}
    $\setminus$ \{`=', `<', `>', `(', `)'\}

<value> ::= `"' <value-quoted> `"' | <value-unquoted>

<value-quoted> ::= <value-char-quoted> <value-quoted>
    | <value-char-quoted>

    <value-char-quoted> ::= \{`\\"'\} $\cup$ \{Set of non-control Unicode
        characters\} $\setminus$ \{`"'\}

<value-unquoted> ::= <value-char-unquoted> <value-unquoted>
    | <value-char-unquoted>

<value-char-unquoted> ::= \{ `\\ ', `\\"', `\\)' \} $\cup$ \{Set of
    non-whitespace, non-control Unicode characters\} $\setminus$ \{`)', `"'\}

<comp-op> ::= `>' | `<' | `=' | `=='

<binary-bool-op> ::= `and' | `or'

<unary-bool-op> ::= `not'

<whitespace> ::= ` ' <whitespace> | ` '

<maybe-whitespace> ::= <whitespace> | $\epsilon$

\end{grammar}
\label{fig:query-bnf}
\caption[BNF description of the query language of \texttt{tagfs}]
    {BNF description of the query language of \texttt{tagfs}. Note that set
    notation is used as a shorthand to describe production rules with many
    terminals. For example the set $\{a, b, c\}$ produces the rule $a \vert b
    \vert c$. \todo{note that tags cannot have the same name as boolean
    operators}}
\end{figure}
% }}}

\subsection{File System Features}
\label{sec:fs-features}

Once the file system has been mounted using the \texttt{tagfs mount} subcommand
it can be interacted with as if it were any other file system on the system.
Figure~\ref{fig:sample-tagfs-tree} shows a possible hierarchy for the FUSE file
system. Within the root directory (in Figure~\ref{fig:sample-tagfs-tree} this
is \texttt{\textcolor{teal}{fuse-mount-root/}}) a directory is created for each
tag in the database. In Figure~\ref{fig:sample-tagfs-tree} these tag
directories are \dir{favourite}, \dir{genre}, \dir{type} and \dir{year}. Each
tag directory has different children based on whether the tag is associated
with a value or not. If a tag does not have an associated value (this is the
case for the \dir{favourite} tag directory in
Figure~\ref{fig:sample-tagfs-tree}) then the corresponding tag directory will
contain a symbolic link for each path that shares the tag. Each symbolic link
points to the tagged path and shares the same name as the last component of the
tagged path. An example of one of these symbolic links is \symlink{Heat (1995)}
in the \dir{favourite} directory. Alternatively, if a tag is associated with a
value then the children of the tag directory are the enumerated values
associated with that tag. An example of this type of tag directory is
\dir{genre} with two associated values represented by the value directories
\dir{crime} and \dir{rock}. Each of these value directories contains symbolic
links to the paths that are tagged with the tag of the parent tag directory and
the value of the value directory. These two types of directories provide an
easy to access method of performing simple queries of the database for a single
tag. However, it is desirable to be able to perform more advanced queries from
the file system.

This is where the query directory (\dir{?/}) is useful. The query directory
contains sub-directories representing each of the stored queries saved by the
\texttt{stored-queries} subcommand. The stored query directories are named with
the format \texttt{<query-name> @ [<query>]}. Each stored query directory
contains the results of executing the stored query the directory represents. In
Figure~\ref{fig:sample-tagfs-tree} the stored query directory is named
\texttt{favourite-crime} and contains the results of executing the
\texttt{type=film and genre=crime and favourite} query, which in this example
is one path represented by the symbolic link \symlink{Heat (1995)}. Stored
queries are useful for saving frequently used queries, but it would be very
restricting to only be able to access the results of queries previously stored
in the system. To make running one-off queries less tedious, the query
directory also supports running arbitrary queries by looking up
`hidden' directories\footnote{These directories are not actually hidden, rather
they do not actually exist until they are looked up.}. These directories are
children of the query directory (\dir{?/}) named after the query they
represent. Using the tags established in Figure~\ref{fig:sample-tagfs-tree} as
an example, looking up the directory \dir{?/genre=rock/} would result in a
directory containing the results of the \texttt{genre=rock} query, which in
this case would be a symbolic link named \symlink{01 Cherub Rock.flac} pointing
to the target \file{/music/The Smashing Pumpkins/Siamese Dream/01 Cherub
Rock.flac}. This is illustrated in Figure~\ref{fig:sample-tagfs-query-dir}.

% Sample tagfs FUSE file hierarchy figure {{{
\begin{figure}
\centering
\begin{forest}
    for tree = {%
        folder,
        grow'=0,
        fit=band,
        font=\ttfamily,
        s sep=0.0mm,
    }
    [fuse-mount-root/,color=teal
        [?,color=teal
            [{favourite-crime @ [type=film and genre=crime and
            favourite]},color=teal
                [\textcolor{purple}{Heat (1995)} -> \textcolor{teal}{/film/Heat
                (1995)/}]
            ]
        ]
        [tags,color=teal
            [film,color=teal
                [Heat (1995).tags,color=olive]
            ]
            [music,color=teal
                [The Smashing Pumpkins,color=teal
                    [Siamese Dream,color=teal
                        [01 Cherub Rock.flac.tags,color=olive]
                        [...,color=black]
                    ]
                ]
            ]
        ]
        [favourite,color=teal
            [\textcolor{purple}{Heat (1995)} -> \textcolor{teal}{/film/Heat
            (1995)/}]
        ]
        [genre,color=teal
            [crime,color=teal
                [\textcolor{purple}{Heat (1995)} -> \textcolor{teal}{/film/Heat
                (1995)/}]
            ]
            [rock,color=teal
                [\textcolor{purple}{01 Cherub Rock.flac} ->
                    \textcolor{olive}{/music/The Smashing Pumpkins/Siamese
                    Dream/01 Cherub Rock.flac}]
                [...,color=black]
            ]
        ]
        [type,color=teal
            [film,color=teal
                [\textcolor{purple}{Heat (1995)} -> \textcolor{teal}{/film/Heat
                (1995)/}]
            ]
            [music,color=teal
                [\textcolor{purple}{01 Cherub Rock.flac} ->
                    \textcolor{olive}{/music/The Smashing Pumpkins/Siamese
                    Dream/01 Cherub
                    Rock.flac}]
                [...]
            ]
        ]
        [year,color=teal
            [1995,color=teal
                [\textcolor{purple}{Heat (1995)} -> \textcolor{teal}{/film/Heat
                (1995)/}]
            ]
            [1993,color=teal
                [\textcolor{purple}{01 Cherub Rock.flac} ->
                    \textcolor{olive}{/music/The Smashing Pumpkins/Siamese
                    Dream/01 Cherub Rock.flac}]
                [...]
            ]
        ]
    ]
\end{forest}
\caption[Sample \texttt{tagfs} FUSE file system hierarchy]
{Sample \texttt{tagfs} FUSE file system hierarchy with directories in
\textcolor{teal}{blue}, files in \textcolor{olive}{green}, and symbolic links
in \textcolor{purple}{pink}. An arrow (`\texttt{->}') following a symbolic link
shows the target that the link is referring to.}
\label{fig:sample-tagfs-tree}
\end{figure}
% }}}

% Arbitrary query tagfs FUSE file hierarchy figure {{{
\begin{figure}
\centering
\begin{forest}
    for tree = {%
        folder,
        grow'=0,
        fit=band,
        font=\ttfamily,
        s sep=0.0mm,
    }
    [fuse-mount-root/?/{genre=rock},color=teal
        [\textcolor{purple}{01 Cherub Rock.flac} ->
            \textcolor{olive}{/music/The Smashing Pumpkins/Siamese
            Dream/01 Cherub
            Rock.flac}]
        [...]
    ]
\end{forest}
\caption[Sample result of looking up an arbitrary query directory.]
{Result of looking up an arbitrary query directory with directories in
\textcolor{teal}{blue}, files in \textcolor{olive}{green}, and symbolic links
in \textcolor{purple}{pink}. An arrow (`\texttt{->}') following a symbolic link
shows the target that the link is referring to.}
\label{fig:sample-tagfs-query-dir}
\end{figure}
% }}}

% sample contents of a .tags file {{{
\begin{figure}
    \centering
    \begin{boxedverbatim}


favourite
genre=crime
type=film
year=1995
    \end{boxedverbatim}
    \caption[Example contents of a \texttt{.tags} file]{Contents of the file
        \file{fuse-mount-root/tags/film/Heat (1995).tags} from
        Figure~\ref{fig:sample-tagfs-tree}}
    \label{fig:tagfs-all-tags-example}
\end{figure}
% }}}

The file system also exposes another special directory: the \dir{tags}
directory. The \dir{tags} directory provides a method of viewing all of the
tags associated with a particular path. Under the \dir{tags} directory a
structure mirroring the hierarchy of all the paths in the system is created.
Browsing this structure is just like browsing the normal file system hierarchy
outside of \texttt{tagfs}. However, the last component of the path is replaced
by a file that has the same name as the last component of the path with an
extra \texttt{.tags} extension. An example of this hierarchy can be seen in
Figure~\ref{fig:sample-tagfs-tree}. Inside each of these \texttt{.tags} files
is a list of all the tags on the path represented by the file. For example,
the file \file{fuse-mount-root/tags/film/Heat (1995).tags} contains a list of
all the tags on the path \texttt{/film/Heat (1995)}. The particular tags for
this example are shown in Figure~\ref{fig:tagfs-all-tags-example}.

The file system is also able to handle modifications to the database whilst it
is mounted. This means that whenever the database is modified, the file system
will adjust to the new database state seamlessly. As such, mounting and
remounting the file system to handle changes is completely unnecessary.

\section{Implementation}
\todo{Talk about order of development, e.g. making empty fs first etc...}
\todo{Talk about how core functionality is implemented as a library separate to
    the cli.}

\subsection{Software Development Practices}

\todo{Talk about use of static analysis - clippy.}
\todo{Talk about use of cargo doc.}

\subsection{Testing}
